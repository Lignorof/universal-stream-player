--- a/lib/core/auth_service.dart
+++ b/lib/core/auth_service.dart
@@ -1,5 +1,4 @@
 import 'dart:convert';
-import 'dart:io' show Platform;
 import 'dart:math';
 import 'package:crypto/crypto.dart';
 import 'package:flutter/foundation.dart' show kIsWeb, ChangeNotifier;
@@ -10,11 +9,11 @@
 
 class AuthService extends ChangeNotifier {
   static final String _spotifyClientId = dotenv.env['SPOTIFY_CLIENT_ID'] ?? '';
-  static bool get _isDesktop => !kIsWeb && (Platform.isWindows || Platform.isLinux || Platform.isMacOS);
+  static final String _deezerAppId = dotenv.env['DEEZER_APP_ID'] ?? '';
+  static bool get _isDesktop => !kIsWeb && (defaultTargetPlatform == TargetPlatform.windows || defaultTargetPlatform == TargetPlatform.linux || defaultTargetPlatform == TargetPlatform.macOS);
   static String get _spotifyRedirectUri => _isDesktop ? 'http://127.0.0.1:8000/callback' : 'usp://callback';
   static String get _spotifyCallbackScheme => _isDesktop ? 'http://127.0.0.1:8000' : 'usp';
-
+  static String get _deezerRedirectUri => _isDesktop ? 'http://127.0.0.1:8001/callback' : 'usp://deezer-callback';
+  static String get _deezerCallbackScheme => _isDesktop ? 'http://127.0.0.1:8001' : 'usp';
   static const String _spotifyTokenKey = 'usp_spotify_access_token';
   static const String _spotifyRefreshTokenKey = 'usp_spotify_refresh_token';
   static const String _deezerTokenKey = 'usp_deezer_access_token';
@@ -22,6 +21,7 @@
   String? _spotifyAccessToken;
   String? _deezerAccessToken;
   String? get spotifyAccessToken => _spotifyAccessToken;
+  String? get deezerAccessToken => _deezerAccessToken;
   bool get isSpotifyAuthenticated => _spotifyAccessToken != null;
   bool get isDeezerAuthenticated => _deezerAccessToken != null;
   bool get isAuthenticated => isSpotifyAuthenticated || isDeezerAuthenticated;
@@ -32,6 +32,7 @@
   Future<void> _loadTokens( ) async {
     final prefs = await SharedPreferences.getInstance();
     _spotifyAccessToken = prefs.getString(_spotifyTokenKey);
+    _deezerAccessToken = prefs.getString(_deezerTokenKey);
     notifyListeners();
   }
 
@@ -39,7 +40,7 @@
   Future<void> loginSpotify() async {
     if (_spotifyClientId.isEmpty) throw Exception('SPOTIFY_CLIENT_ID não encontrado no .env');
     final codeVerifier = _generateRandomString(128);
-    final codeChallenge = _generateCodeChallenge(codeVerifier);
-    final scopes = ['user-read-private', 'playlist-read-private', 'user-library-read'].join(' ');
+    final codeChallenge = _generateCodeChallenge(codeVerifier); // PKCE
+    final scopes = ['user-read-private', 'playlist-read-private', 'user-library-read', 'offline_access'].join(' ');
 
     final authUrl = Uri.https('accounts.spotify.com', '/authorize', {
       'response_type': 'code',
@@ -53,11 +54,34 @@
     try {
       final result = await FlutterWebAuth2.authenticate(url: authUrl.toString( ), callbackUrlScheme: _spotifyCallbackScheme);
       final code = Uri.parse(result).queryParameters['code'];
-      if (code != null) await _exchangeSpotifyCode(code, codeVerifier);
-      else throw Exception('Código de autorização não retornado.');
+      if (code != null) {
+        await _exchangeSpotifyCode(code, codeVerifier);
+      } else {
+        throw Exception('Código de autorização não retornado.');
+      }
     } catch (e) {
       if (e.toString().contains('CANCELED')) return; // O usuário cancelou, não é um erro.
       throw Exception('Falha no login com Spotify: $e');
     }
   }
 
+  Future<void> loginDeezer() async {
+    if (_deezerAppId.isEmpty) throw Exception('DEEZER_APP_ID não encontrado no .env');
+
+    final authUrl = Uri.https('connect.deezer.com', '/oauth/auth.php', {
+      'app_id': _deezerAppId,
+      'redirect_uri': _deezerRedirectUri,
+      'perms': 'basic_access,manage_library', // Escopos para Deezer
+      'response_type': 'token', // Deezer usa o fluxo implícito, mais simples
+    } );
+
+    try {
+      final result = await FlutterWebAuth2.authenticate(url: authUrl.toString(), callbackUrlScheme: _deezerCallbackScheme);
+      final fragment = Uri.parse(result).fragment;
+      final token = Uri.splitQueryString(fragment)['access_token'];
+      if (token != null) {
+        _deezerAccessToken = token;
+        final prefs = await SharedPreferences.getInstance();
+        await prefs.setString(_deezerTokenKey, _deezerAccessToken!);
+        notifyListeners();
+      } else {
+        throw Exception('Token do Deezer não encontrado.');
+      }
+    } catch (e) {
+      if (e.toString().contains('CANCELED')) return;
+      throw Exception('Falha no login com Deezer: $e');
+    }
+  }
+
   Future<void> _exchangeSpotifyCode(String code, String codeVerifier) async {
     final url = Uri.parse('https://accounts.spotify.com/api/token' );
 
@@ -118,6 +142,7 @@
     _deezerAccessToken = null;
     final prefs = await SharedPreferences.getInstance();
     await prefs.remove(_spotifyTokenKey);
+    await prefs.remove(_spotifyRefreshTokenKey);
     await prefs.remove(_deezerTokenKey);
     notifyListeners(); // Essencial para a UI reagir e voltar para a tela de login
   }
--- /dev/null
+++ b/lib/core/deezer_api_service.dart
@@ -0,0 +1,33 @@
+import 'dart:convert';
+import 'package:http/http.dart' as http;
+import 'stream_playlist.dart';
+
+class DeezerApiService {
+  final String _accessToken;
+  static const String _baseUrl = 'https://api.deezer.com';
+
+  DeezerApiService(this._accessToken );
+
+  Future<List<StreamPlaylist>> getCurrentUserPlaylists() async {
+    // A API do Deezer requer o token como um parâmetro de query
+    final url = Uri.parse('$_baseUrl/user/me/playlists?access_token=$_accessToken');
+
+    final response = await http.get(url );
+
+    if (response.statusCode == 200) {
+      final data = jsonDecode(response.body);
+      // A resposta do Deezer para playlists está na chave 'data'
+      final itemsList = (data['data'] as List?);
+      if (itemsList == null) {
+        return <StreamPlaylist>[];
+      }
+      return itemsList
+          .map((item) => StreamPlaylist.fromDeezerJson(item))
+          .toList();
+    } else {
+      // A API do Deezer pode retornar erros de token aqui.
+      // Uma implementação mais robusta lidaria com a expiração do token.
+      throw Exception('Falha ao carregar playlists do Deezer: ${response.body}');
+    }
+  }
+}
--- a/lib/core/stream_playlist.dart
+++ b/lib/core/stream_playlist.dart
@@ -21,6 +21,18 @@
     );
   }
 
+  // Construtor para dados vindos da API do Deezer
+  factory StreamPlaylist.fromDeezerJson(Map<String, dynamic> json) {
+    return StreamPlaylist(
+      // O ID do Deezer é um int, convertemos para String para consistência
+      id: json['id']?.toString() ?? '',
+      name: json['title'] ?? 'Playlist Sem Nome',
+      // Deezer tem diferentes tamanhos de imagem, pegamos a média
+      imageUrl: json['picture_medium'] ?? '',
+      owner: json['user']?['name'] ?? 'Desconhecido',
+      source: 'deezer',
+    );
+  }
+
   // Construtor para dados vindos do nosso banco de dados
   factory StreamPlaylist.fromDbJson(Map<String, dynamic> json) {
     return StreamPlaylist(
--- a/lib/ui/home_screen.dart
+++ b/lib/ui/home_screen.dart
@@ -52,6 +52,18 @@
                   onPressed: () => _login(context, authService.loginSpotify),
                   child: const Text('Login com Spotify'),
                 ),
+                const SizedBox(height: 16),
+                const Text('ou'),
+                const SizedBox(height: 16),
+                ElevatedButton(
+                  style: ElevatedButton.styleFrom(
+                    backgroundColor: const Color(0xFFFEAA2D), // Cor do Deezer
+                    foregroundColor: Colors.black,
+                    minimumSize: const Size(200, 50),
+                  ),
+                  onPressed: () => _login(context, authService.loginDeezer),
+                  child: const Text('Login com Deezer'),
+                ),
               ],
             ),
           ),
--- a/lib/ui/library_screen.dart
+++ b/lib/ui/library_screen.dart
@@ -2,6 +2,7 @@
 import 'package:provider/provider.dart';
 import '../core/auth_service.dart';
 import '../core/stream_playlist.dart';
+import '../core/deezer_api_service.dart';
 import '../core/stream_track.dart';
 import '../core/spotify_api_service.dart';
 import 'playlist_screen.dart';
@@ -15,7 +16,7 @@
 class _LibraryScreenState extends State<LibraryScreen>
     with SingleTickerProviderStateMixin {
   late TabController _tabController;
-  late Future<List<StreamPlaylist>> _playlistsFuture;
+  late Future<List<StreamPlaylist>> _combinedPlaylistsFuture;
   late Future<List<StreamTrack>> _tracksFuture;
 
   @override
@@ -23,17 +24,31 @@
     super.initState();
     final authService = context.read<AuthService>();
     final spotifyService = SpotifyApiService(authService.spotifyAccessToken!, authService);
-    _playlistsFuture = spotifyService.getCurrentUserPlaylists();
+    _combinedPlaylistsFuture = _loadCombinedPlaylists(authService);
     _tracksFuture = spotifyService.getSavedTracks();
     _tabController = TabController(length: 2, vsync: this);
   }
 
+  Future<List<StreamPlaylist>> _loadCombinedPlaylists(AuthService authService) async {
+    List<StreamPlaylist> combinedList = [];
+
+    if (authService.isSpotifyAuthenticated) {
+      final spotifyService = SpotifyApiService(authService.spotifyAccessToken!, authService);
+      final spotifyPlaylists = await spotifyService.getCurrentUserPlaylists();
+      combinedList.addAll(spotifyPlaylists);
+    }
+
+    if (authService.isDeezerAuthenticated) {
+      final deezerService = DeezerApiService(authService.deezerAccessToken!);
+      final deezerPlaylists = await deezerService.getCurrentUserPlaylists();
+      combinedList.addAll(deezerPlaylists);
+    }
+
+    // TODO: Adicionar uma lógica de ordenação, por exemplo, por nome.
+    combinedList.sort((a, b) => a.name.toLowerCase().compareTo(b.name.toLowerCase()));
+
+    return combinedList;
+  }
+
   @override
   void dispose() {
     _tabController.dispose();
@@ -55,7 +70,7 @@
         children: [
           // Aba de Playlists
           _buildFutureList<StreamPlaylist>(
-            future: _playlistsFuture,
+            future: _combinedPlaylistsFuture,
             itemBuilder: (playlist) => ListTile(
               leading: playlist.imageUrl.isNotEmpty
                   ? Image.network(playlist.imageUrl, width: 50, height: 50, fit: BoxFit.cover)

